# spc9_analyzer.py takes the text file generated by paired_end_filter.py
# which contains quality-filtered paired forward and reverse FASTQ reads
# spc9_analyzer.py then generates an MS Excel file with spc9 mutation frequency
# and normalized mutated reads for each barcoded PCR sample that was run on 
# the Illumina MiSeq
# The barcodes used in the test at the bottom are for the data 
# in Hossain et al., 2021 Figure 3F

from Bio import SeqIO
import pandas as pd
from operator import itemgetter


# Function takes as input a fasta file of a phage PCR product
# and returns a string of only the DNA sequence
# In this case, the fasta file is "spc9_pcr_rev_comp.fa"
def pcr_product(filename):
    # Open fasta file as read-only
    f = open(filename, "r")

    # Read the file into a string
    # and eliminate new line characters
    # Creates a list of DNA sequences for each line of the fasta file
    s = f.read().split("\r\n")

    # Join the list entries into a single string
    # Converts the entire phage genomic DNA sequence into a single string
    dna_string = "".join(s[1:len(s)])

    # Close the file
    f.close()

    return dna_string.upper()


def total_reads(combined_reads_file):
    # Open quality-filtered paired-end combined reads txt file as read-only
    f = open(combined_reads_file, "r")

    # Create a list of sequence reads from all the entries in the fastq file
    # First, read the entire fastq file into a string
    # Split the string into a list
    # where each list entry is a line in the fastq file
    # The second line of the fastq file contains the first sequence read
    # and every fourth line from that point on contains a subsequent sequence read
    fastq_seq_list = []

    for line in f:
        reads_split = line.split("\t")
        fwd_read = reads_split[0]
        rev_read = reads_split[1]
        rev_read_proper = rev_read.split("\n")[0]
        fastq_seq_list.append((fwd_read, rev_read_proper))

    # Close the file
    f.close()

    return fastq_seq_list


# Function separates reads into individual lists based on barcodes
# The user specifies the sample number from our list of barcoded samples
def barcode_list(combined_reads_list, sample):
    # Create an empty list for user-specified barcoded sample
    sample_barcode_list = []
    # Adjust sample number accordingly for Pythonic code
    sample_number = sample - 1

    for i in range(0, len(combined_reads_list)):
        # Search for barcode at the start of each read
        # Only add appropriate barcoded read to the list if barcode is at the beginning of the read
        if barcode[sample_number] in combined_reads_list[i][0] and combined_reads_list[i][1]:
            if "TTCATTAAACCACGCCAGCAGC" in combined_reads_list[i][0]:
                if barcodes[sample_number] in combined_reads_list[i][0]:
                    # If present, add read to the list
                    read = (combined_reads_list[i][0])
                    barcode_minus_read = read[len(barcodes[sample_number]):len(read) + 1]
                    sample_barcode_list.append(barcode_minus_read)
            elif "TTCATTAAACCACGCCAGCAGC" in combined_reads_list[i][1]:
                if barcodes[sample_number] in combined_reads_list[i][1]:
                    # If present, add read to the list
                    read = (combined_reads_list[i][1])
                    barcode_minus_read = read[len(barcodes[sample_number]):len(read) + 1]
                    sample_barcode_list.append(barcode_minus_read)

    return sample_barcode_list


# Function takes as input a pcr product string, a barcoded subtracted reads list, and a sample number
# from our list of samples and returns a list of all the mutations detected
# and a list of the total counts of each mutation for the user-specified barcoded sample
def mut_counter(pcr_fasta_file, barcode_minus_list):
    # Create an empty list to record escape mutations in our spacer
    mutations_list = []

    # Iterate through each read in the list
    for read in barcode_minus_list:
        # Enumerate each position and base corresponding to the spacer sequence (including the PAM) in the read
        for i, b in enumerate(read[38:71]):
            # For each position and base in the read, go through each position and base of the WT spacer sequence
            # The first two TTs are trimmed off the original pcr product fasta file
            # since these are trimmed off the reads during barcode trimming
            for j, c in enumerate(pcr_fasta_file[38:71]):
                # If the base position in the read matches the base position in the WT spacer sequence
                if i == j:
                    # If the base in the read mismatches the base in the WT spacer sequence for any position
                    if b != c:
                        # Record the position in the spacer with NGG as 0, -1, -2 respectively
                        position = i - 2
                        # Record the mismatched base in the read
                        # Since this base is a reverse complement, we need to switch it accordingly
                        mutated_base_rev_comp = b
                        mutated_base = "N"
                        if mutated_base_rev_comp == "A":
                            mutated_base = "T"
                        elif mutated_base_rev_comp == "T":
                            mutated_base = "A"
                        elif mutated_base_rev_comp == "C":
                            mutated_base = "G"
                        elif mutated_base_rev_comp == "G":
                            mutated_base = "C"
                        # Add each mutated base position and mutated base to the list of escape mutations
                        mutations_list.append((position, mutated_base))
                        break

    # Create an empty dictionary to record and count all escape mutations encountered
    mutation_count_dict = {}

    # Iterate through each mutation in the mutations list
    for position, mutation in mutations_list:
        # Combine base position and base mutation into a single string
        # These will be used as the keys for the dictionary
        mut_position = str(position) + mutation

        # If the mutation has already been recorded in the dictionary, increment its value by 1
        if mut_position in mutation_count_dict:
            mutation_count_dict[mut_position] += 1
        # If the mutation has not been recorded yet, add it to the dictionary with a value of 1
        else:
            mutation_count_dict[mut_position] = 1

    # Create a variable for the total number of mutations detected
    total_mut_count = 0

    # Iterate through the dictionary to sum the counts for each mutation
    for count in mutation_count_dict.values():
        total_mut_count += count

    # Record the total number of reads in the above list for normalization
    total_read_count = len(barcode_minus_list)

    # Convert the mutation count dictionary to a list
    # First initiate an empty list
    mutation_count_list = []

    # Iterate through the keys and values in the dictionary
    for mutation, count in mutation_count_dict.items():
        # Record the mutation position
        position = int(mutation[0:len(mutation) - 1])
        # Record the mutated base
        base = mutation[len(mutation) - 1]
        # Calculate the fraction of total mutations the mutation accounts for
        mutation_fraction = float(count) / float(total_mut_count)
        # Calculate a normalized to reads mutation count,
        # which is the mutation count normalized to the total reads being analyzed
        normalized_count = float(count) / float(total_read_count)

        # Add a tuple of position, base mutation, (position + mutation),
        # mutation count, mutation fraction and normalized count to the growing list
        mutation_count_list.append((position, base, mutation, count, mutation_fraction, normalized_count))

    # Sort the list in order of mutation position from lowest (PAM) to highest (PAM distal)
    mutation_count_list.sort()

    return mutation_count_list


def mut_count_file_generator(pcr_fasta_file, combined_reads_file, total_sample_number):
    # Convert pcr product fasta file to a sequence string
    spacer_seq = pcr_product(pcr_fasta_file)
    # Get a single list of all the combined reads from the forward and reverse fastq files
    total_reads_list = total_reads(combined_reads_file)

    # Iterate through each barcoded sample
    for i in range(0, total_sample_number):
        # Get a list of reads corresponding to a specific barcode and subtract the barcode from the read
        barcode_minus_list = barcode_list(total_reads_list, i + 1)
        # Get a list of the escape mutation counts for the specified barcoded sample
        mutation_list = mut_counter(spacer_seq, barcode_minus_list)
        # Convert this list of tuples to a pandas dataframe
        df_mut_list = pd.DataFrame(mutation_list,
                                   columns=["Position (bp)", "Mutation", "Escape mutation",
                                            "Count", "Fraction of total", "Normalized Count"])
        # Write the dataframe to a csv file
        # This output csv file contains a count of escape mutations for a specific sample
        df_mut_list.to_csv("072121 Spc9 Escape Mutations wt Ecoli DdinB Ecoli - Sample " + str(i + 1) + ".csv")

    return "Done!"


# Create a list of barcodes
# TT (the first two bases of pcr product after each barcode) added to the end of each barcode
# because shorter barcodes are present twice in some reads
# 16 barcodes in total for 16 pcr samples
# Barcodes correspond to respective PCR samples 1-16
barcodes = ["CAAATT", "ACCCATT", "GTGGGATT", "TGCTTTATT", "TGCATTACTT", "TACGTAGCCTT", "CCGCTT", "AGATCTT",
            "ATCCAGTT", "TACAACGTT", "TGCACTGGTT", "TCAGCGGTGTT", "AGATTT", "GCTCTTT", "CATCGATT", "TCATATATT"]

barcode = ["CAAA", "CCCA", "GGGA", "TTTA", "TTAC", "AGCC", "CCGC", "GATC", "CCAG", "AACG", "CTGG",
           "GGTG", "AGAT", "CTCT", "TCGA", "TATA"]

# Test to generate data used for the graph in Hossain et al., 2021 Figure 3F
print "Start"

reads_list = total_reads("Spc9MutSeq_S1_L001_R1_R2_combined_quality.txt")

print barcode_list(reads_list, 5)[0:50]

print mut_count_file_generator("spc9_pcr_rev_comp.fa", "Spc9MutSeq_S1_L001_R1_R2_combined_quality.txt", 16)

print "Done!"
